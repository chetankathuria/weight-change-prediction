# -*- coding: utf-8 -*-
"""Weight change prediction Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KkP_MgA2aL_h7QBxUUFNoJOM9CO-QkeM
"""

# Importing important libraries
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error
import joblib

# Loading data
df = pd.read_csv('weight_change_dataset.csv')

"""Step 1: Data Preprocessing"""

# Checking Data Types
df.dtypes

# Feature Engineering

# 1. Caloric_Intake_per_Weight

df['Caloric_Intake_per_Weight'] = df['Daily Calories Consumed'] / df['Current Weight (lbs)']

# 2. activity-weighted calories

# Assuming 'Physical Activity Level' is encoded with 0 being the least active
# and higher values representing more activity

# Defining activity weights
activity_weights = {
    0: 1.0,  # Sedentary
    1: 1.2,  # Lightly Active
    2: 1.4,  # Moderately Active
    3: 1.6   # Very Active
}

df['Activity_Weighted_Calories'] = df['Daily Calories Consumed'] * df['Physical Activity Level'].map(activity_weights)

"""Step 2: Exploratory Data Analysis (EDA)"""

df.columns

df.isnull().sum().sum()

df.info()

print(f"Number of Rows: {df.shape[0]} \nNumber of Columns: {df.shape[1]}")

"""Showing frequency of unique value in every column and also displays how StandardScaling and LabelEncoding has transformed values."""

for col in df.columns:
    print(f'\n{df[col].value_counts()}\n=================================')

# Encoding categorical variables
label_encoders = {}
for column in ['Gender', 'Physical Activity Level', 'Sleep Quality']:
    le = LabelEncoder()
    df[column] = le.fit_transform(df[column])
    label_encoders[column] = le

# Scaling numerical features
scaler = StandardScaler()
numerical_features = ['Participant ID', 'Age', 'Current Weight (lbs)', 'BMR (Calories)',
                      'Daily Calories Consumed','Daily Caloric Surplus/Deficit','Weight Change (lbs)',
                      'Duration (weeks)','Physical Activity Level','Stress Level','Final Weight (lbs)']
df[numerical_features] = scaler.fit_transform(df[numerical_features])

# fig, axes = plt.subplots(len(numerical_features[:-2]), 1, figsize=(10, 5 * len(numerical_features[:-2])))

# for i, col in enumerate(numerical_features[:-2]):
#     sns.boxplot(x=df[col], ax=axes[i])
#     axes[i].set_title(col)
# plt.show()

# Checking for Outliers by plotting Box Plot

import seaborn as sns
import matplotlib.pyplot as plt

for col in numerical_features[:-2]:
    sns.boxplot(x=df[col])
    plt.title(col)
    plt.show()

"""Checking Outliers and Handling them"""

# Handling outliers in columns:
#'Daily Calories Consumed', 'Weight Change (lbs)'

for column in ['Daily Calories Consumed', 'Weight Change (lbs)']:
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Identifying outliers
    outliers = df[(df[column] < lower_bound) | (df[column] > upper_bound)]
print(outliers)
    # Remove or replace outliers

    # Option 1: Remove outliers
    # df = df[~df.index.isin(outliers.index)]  # Keep rows without outliers

    # Option 2: Replace with upper/lower bounds (capping/flooring)
    # df.loc[df[column] < lower_bound, column] = lower_bound
    # df.loc[df[column] > upper_bound, column] = upper_bound

# Visualizing Feature Distributions

for col in numerical_features:
    plt.figure(figsize=(6, 4))
    sns.histplot(df[col], kde=True, bins=20)
    plt.title(f'Distribution of {col}')
    plt.xlabel(col)
    plt.ylabel('Frequency')
    plt.show()

plt.figure(figsize=(8, 6))
plt.scatter(df['Daily Caloric Surplus/Deficit'], df['Weight Change (lbs)'])
plt.xlabel("Daily Caloric Surplus/Deficit")
plt.ylabel("Weight Change (lbs)")
plt.title("Scatter Plot of Daily Caloric Surplus/Deficit vs. Weight Change")
plt.show()

# Calculating correlation matrix
correlation_matrix = df.corr()

# Plot heatmap
plt.figure(figsize=(12, 10))  # Adjust figsize as needed
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title("Correlation Matrix")
plt.show()

print(df['Weight Change (lbs)'].describe())

plt.figure(figsize=(10, 6))
sns.boxplot(x='Gender', y='Weight Change (lbs)', data=df)
plt.title("Weight Change Distribution by Gender")
plt.show()

plt.figure(figsize=(10, 6))
sns.boxplot(x='Physical Activity Level', y='Weight Change (lbs)', data=df)
plt.title("Weight Change Distribution by Physical Activity Level")
plt.show()

print(df.groupby('Gender')['Weight Change (lbs)'].describe())
print(df.groupby('Physical Activity Level')['Weight Change (lbs)'].describe())

"""Step 3: Model Selection"""

# Splitting the data 80:20 and dropping Target variable, unimportant column
X = df.drop(['Participant ID', 'Final Weight (lbs)'], axis=1)
y = df['Final Weight (lbs)']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Define models
models = {
    'Linear Regression': LinearRegression(),
    'Decision Tree': DecisionTreeRegressor(),
    'Gradient Boosting': GradientBoostingRegressor()
}

# Evaluating models
best_model = None
best_score = float('inf')

for model_name, model in models.items():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    mae = mean_absolute_error(y_test, y_pred)
    mse = mean_squared_error(y_test, y_pred, squared=False)
    print(f"{model_name} - MAE: {mae}, MSE: {mse}")

    # Selecting best model based on MSE
    if mse < best_score:
        best_score = mse
        best_model = model

print(f"\nSelected Model is: {best_model}")
print()

"""Performing Hyperparmeter Tuning"""

from sklearn.model_selection import GridSearchCV, RandomizedSearchCV
param_grid = {'fit_intercept': [True, False]}

grid_search = GridSearchCV(LinearRegression(), param_grid, scoring='neg_mean_squared_error', cv=5)
grid_search.fit(X_train, y_train)

random_search = RandomizedSearchCV(LinearRegression(), param_distributions=param_grid, scoring='neg_mean_squared_error', cv=5, n_iter=10)
random_search.fit(X_train, y_train)

# Saving model and preprocessing objects
joblib.dump(best_model, 'weight_change_prediction_model.pkl')
joblib.dump(scaler, 'scaler.pkl')
joblib.dump(label_encoders, 'label_encoders.pkl')
joblib.dump(mse,'mse.pkl')

joblib.dump(best_model, 'linear_regression_model.pkl')

def predict_final_weight(input_data):
    """
    Predicts the final weight based on user inputs.

    Args:
        input_data: A tuple or list of user inputs.
                      Make sure the order of inputs matches the order of features used during training.

    Returns:
        The predicted final weight.
    """
    model = joblib.load('linear_regression_model.pkl')  # Load the saved model

    # Reshape the input data
    input_data_as_numpy_array = np.asarray(input_data)
    input_data_reshaped = input_data_as_numpy_array.reshape(1, -1)

    prediction = model.predict(input_data_reshaped)
    return prediction[0]  # Return the predicted value

!pip install streamlit

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py

import streamlit as st

model = joblib.load('weight_change_prediction_model.pkl')
scaler = joblib.load('scaler.pkl')
label_encoders = joblib.load('label_encoders.pkl')

model = joblib.load('weight_change_prediction_model.pkl')
scaler = joblib.load('scaler.pkl')
label_encoders = joblib.load('label_encoders.pkl')

st.title("Final Weight Prediction App")

# Input fields for user data
Age = st.number_input("Age")
Gender = st.selectbox("Gender", label_encoders['Gender'].classes_)
Current_Weight = st.number_input("Current Weight (lbs)", min_value=0.0)
BMR_Calories = st.number_input("BMR (Calories)", min_value=0.0)
Daily_Calories_Consumed = st.number_input("Daily Calories Consumed", min_value=0.0)
Daily_Caloric_Surplus_Deficit = st.number_input("Daily Caloric Surplus/Deficit", min_value=0.0)
Weight_Change = st.number_input("Weight Change (lbs)", min_value=0.0)
Duration = st.number_input("Duration (weeks)", min_value=0.0)
Physical_Activity_Level = st.selectbox("Physical Activity Level", label_encoders['Physical Activity Level'].classes_)
Sleep_Quality = st.selectbox("Sleep Quality", label_encoders['Sleep Quality'].classes_)
Stress_Level = st.number_input("Stress Level", min_value=0.0)


if st.button("Predict"):
       # Collect user inputs into a tuple
       input_data = (Age, Gender, Current_Weight, BMR_Calories, Daily_Calories_Consumed,
                     Daily_Caloric_Surplus_Deficit, Weight_Change, Duration, Physical_Activity_Level,
                     Sleep_Quality, Stress_Level)

       # Feature scaling and encoding (if needed):
       # Apply scaling to numerical features using scaler.transform()
       # Apply encoding to categorical features using label_encoders[column_name].transform()
       # Make prediction
       prediction = model.predict(input_data)

       # Display prediction
       st.write(f"Predicted Final Weight: {prediction:.2f} lbs")


'''
Daily Caloric Surplus/Deficit', 'Weight Change (lbs)',
       'Duration (weeks)', 'Physical Activity Level', 'Sleep Quality',
       'Stress Level', 'Final Weight (lbs)

# ... (Add other input fields for all necessary features)

if st.button("Predict"):
    # Collect user inputs into a tuple
    input_data = (age,
                  # ... (Include all other user inputs in the correct order)
                  )

    # Make prediction
    prediction = predict_final_weight(input_data)

    # Display prediction
    st.write(f"Predicted Final Weight: {prediction:.2f} lbs")'''

!streamlit run app.py

!git init
!git add .
!git commit -m "Initial commit"

!git remote add origin https://github.com/chetankathuria
!git push -u origin main

!git push -u origin main

!git config --global user.name "Chetan Kathuria"
!git config --global user.email "https://github.com/chetankathuria"

# !git branch
!git add .
!git commit -m "Initial Commit"

!git status

!git branch

!git push -u origin main

!git remote -v













# Commented out IPython magic to ensure Python compatibility.
# %%writefile app2.py
# import streamlit as st
# import joblib
# import numpy as np
# 
# # Load model and preprocessing files
# model = joblib.load('weight_change_prediction_model.pkl')
# scaler = joblib.load('scaler.pkl')
# label_encoders = joblib.load('label_encoders.pkl')
# rmse= joblib.load('mse.pkl')
# 
# 
# # Title and inputs
# st.title("Weight Change Prediction")
# st.write("Enter the existing weight and other details below to get possible weight change prediction.")
# 
# 
# ''' 'Participant ID', 'Age', 'Gender', 'Current Weight (lbs)',
#        'BMR (Calories)', 'Daily Calories Consumed',
#        'Daily Caloric Surplus/Deficit', 'Weight Change (lbs)',
#        'Duration (weeks)', 'Physical Activity Level', 'Sleep Quality',
#        'Stress Level', 'Final Weight (lbs)', 'Caloric_Intake_per_Weight',
#        'Activity_Weighted_Calories' '''
# 
# # Inputs for each feature
# Age = st.number_input("Age", min_value=0.0)
# Gender = st.selectbox("Gender", label_encoders['Gender'].classes_)
# Current Weight(lbs) = st.number_input("Current Weight (lbs)", min_value=0.0)
# BMR (Calories) = st.number_input("BMR (Calories)", min_value=0.0)
# Daily Calories Consumed = st.number_input("Daily Calories Consumed", min_value=0.0)
# ---
# 
# irrigation_type = st.selectbox("Irrigation Type", label_encoders['Irrigation_Type'].classes_)
# soil_type = st.selectbox("Soil Type", label_encoders['Soil_Type'].classes_)
# season = st.selectbox("Season", label_encoders['Season'].classes_)
# farm_area = st.number_input("Farm Area (acres)", min_value=0.0)
# fertilizer_used = st.number_input("Fertilizer Used (tons)", min_value=0.0)
# pesticide_used = st.number_input("Pesticide Used (kg)", min_value=0.0)
# water_usage = st.number_input("Water Usage (cubic meters)", min_value=0.0)
# 
# # Encode categorical inputs and scale numerical inputs
# inputs = np.array([
#     label_encoders['Crop_Type'].transform([crop_type])[0],
#     label_encoders['Irrigation_Type'].transform([irrigation_type])[0],
#     label_encoders['Soil_Type'].transform([soil_type])[0],
#     label_encoders['Season'].transform([season])[0],
#     farm_area, fertilizer_used, pesticide_used, water_usage
# ]).reshape(1, -1)
# inputs[:, 4:] = scaler.transform(inputs[:, 4:])
# 
# # Predict yield
# if st.button("Predict Yield"):
#     prediction = model.predict(inputs)
#     st.write(f"Predicted Crop Yield: {prediction[0]:.2f} tons")
#     st.write(f"Error :{rmse}")